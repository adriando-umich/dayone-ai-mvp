<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DayOne.ai - Interview Simulation</title>
  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet">
  <!-- Prism for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/eclipse.min.css" rel="stylesheet" />
  <style>
    :root {
      /* Palette */
      --bg: #f8f9fa;
      /* Light gray background */
      --card: #ffffff;
      --sidebar: #f0f2f5;
      --border: #e1e4e8;

      --text-primary: #1d1c1d;
      /* Slack-like black */
      --text-secondary: #616061;
      --text-muted: #868686;

      --accent: #1264a3;
      /* Slack blue */
      --accent-hover: #0b4d71;

      /* Role Colors for Avatars */
      --role-qa: #e01e5a;
      /* Redish */
      --role-ba: #e8912d;
      /* Orange */
      --role-tech-lead: #2bac76;
      /* Green */
      --role-candidate: #4c9689;
      /* Teal */
      --role-system: #616061;
      /* Gray */

      /* IDE Colors - LIGHT THEME NOW */
      --ide-bg: #ffffff;
      --ide-fg: #24292e;
      --ide-tab-bg: #f0f0f0;
      --ide-tab-active: #ffffff;
      --ide-tab-text: #586069;
      --ide-border: #e1e4e8;
      --ide-line: #f6f8fa;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: var(--text-primary);
      background: var(--bg);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }

    /* Layout */
    .wrap {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: 20px;
      height: calc(100dvh - 12px);
      overflow-x: hidden;
      overflow-y: auto;
    }

    /* Panels */
    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
    }

    .panel-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: #fcfcfc;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .panel-title {
      font-weight: 700;
      font-size: 15px;
      margin: 0;
    }
    .panel-tools {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--text-secondary);
    }
    .panel-tools label {
      margin: 0;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
    }
    .panel-tools input[type="checkbox"] {
      width: 14px;
      height: 14px;
      margin: 0;
      padding: 0;
      accent-color: var(--accent);
      cursor: pointer;
    }

    .panel-body {
      padding: 16px;
      overflow-y: auto;
      flex: 1;
    }

    /* Left Sidebar Specifics */
    .control-panel {
      gap: 16px;
      display: flex;
      flex-direction: column;
    }
    .control-panel .panel-body {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 6px;
    }

    input,
    select,
    textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 10px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(18, 100, 163, 0.1);
    }

    /* IDE-like Code Editor Input (Light Mode) */
    textarea.code-editor {
      font-family: "Fira Code", monospace;
      background: #ffffff;
      color: var(--text-primary);
      border: 1px solid var(--border);
      min-height: 260px;
      line-height: 1.5;
      tab-size: 2;
    }
    .snippet-group {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .snippet-group textarea.code-editor {
      flex: 1 1 auto;
      min-height: 240px;
    }
    .snippet-group .CodeMirror {
      flex: 1 1 auto;
      min-height: 240px;
      max-height: 48vh;
      height: 100%;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-family: "Fira Code", monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    .snippet-actions {
      position: sticky;
      bottom: 0;
      z-index: 8;
      padding-top: 10px;
      margin-top: 10px;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0), #fff 28px);
    }

    button {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: var(--accent-hover);
    }

    button.secondary {
      background: white;
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    button.secondary:hover {
      background: #f8f8f8;
    }

    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    .btn-row.wrap {
      flex-wrap: wrap;
    }
    .coming-soon-btn {
      opacity: 0.55;
      filter: saturate(0.2);
      cursor: not-allowed;
    }
    .snippet-capture-inline {
      margin-top: 8px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .recording-indicator {
      display: none;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid #d0d7de;
      background: #fff;
      color: #b42318;
      position: relative;
    }
    .recording-indicator.show {
      display: inline-flex;
    }
    .recording-indicator.live {
      box-shadow: 0 0 0 3px rgba(180, 35, 24, 0.18);
    }
    .recording-indicator .rec-dot {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #d92d20;
      animation: recPulse 1.1s ease-in-out infinite;
    }
    .recording-indicator .rec-icon {
      width: 13px;
      height: 13px;
      display: block;
      fill: currentColor;
    }
    @keyframes recPulse {
      0%, 100% { transform: scale(1); opacity: 0.55; }
      50% { transform: scale(1.2); opacity: 1; }
    }

    .timer-display {
      font-family: "Fira Code", monospace;
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      text-align: center;
      margin: 10px 0;
      letter-spacing: -1px;
    }

    /* Right Side Layout */
    .stack {
      display: grid;
      grid-template-rows: minmax(0, 1fr) minmax(0, 1fr);
      /* Split vertically */
      gap: 20px;
      height: 100%;
      min-height: 0;
    }

    .stack-bottom {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      min-height: 0;
      height: 100%;
      overflow: hidden;
    }
    .stack-bottom .panel {
      min-height: 0;
    }

    /* IDE Tabs (Light) */
    .ide-panel {
      background: var(--card);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .ide-tabs {
      display: flex;
      background: var(--ide-tab-bg);
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
    }

    .ide-tab {
      padding: 10px 20px;
      font-size: 13px;
      color: var(--ide-tab-text);
      background: transparent;
      border-right: 1px solid var(--border);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 120px;
      justify-content: center;
    }

    .ide-tab:hover {
      background: rgba(255, 255, 255, 0.5);
      color: var(--text-primary);
    }

    .ide-tab.active {
      background: var(--ide-tab-active);
      color: var(--text-primary);
      border-top: 2px solid var(--accent);
      font-weight: 500;
    }

    .ide-content {
      flex: 1;
      overflow: auto;
      padding: 0;
      margin: 0;
      background: var(--card);
      /* Light bg */
      min-height: 0;
    }

    /* Prism overrides for Light Theme */
    pre[class*="language-"] {
      margin: 0 !important;
      height: 100%;
      border-radius: 0 !important;
      background: var(--card) !important;
      text-shadow: none !important;
      border: none !important;
      font-family: "Fira Code", monospace !important;
      font-size: 13px !important;
    }

    /* Slack-like Multi Chat */
    .chat-panel {
      min-height: 0;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    .multi-chat {
      min-height: 0;
      flex: 1 1 auto;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      padding: 10px;
      background: #f8fafc;
    }
    .role-window {
      min-height: 0;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      overflow: hidden;
    }
    .role-header {
      padding: 4px 10px;
      border-bottom: 1px solid var(--border);
      background: #fbfcfd;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 12px;
      font-weight: 600;
    }
    .role-header-main {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .role-header-tools {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .role-badge {
      min-width: 18px;
      height: 18px;
      border-radius: 999px;
      background: var(--accent);
      color: #fff;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
    }
    .role-badge.hidden {
      display: none;
    }
    .role-call-btn {
      width: 24px;
      height: 24px;
      min-width: 24px;
      padding: 0;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .role-call-btn .call-icon {
      width: 13px;
      height: 13px;
      display: block;
      fill: currentColor;
    }
    .role-feed {
      min-height: 0;
      flex: 1 1 auto;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 10px;
      scrollbar-gutter: stable;
    }
    .role-feed::-webkit-scrollbar {
      width: 10px;
    }
    .role-feed::-webkit-scrollbar-thumb {
      background: #b8bcc2;
      border-radius: 10px;
      border: 2px solid #f3f4f6;
    }
    .role-feed::-webkit-scrollbar-track {
      background: #f3f4f6;
    }
    .role-compose {
      border-top: 1px solid var(--border);
      padding: 8px;
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 6px;
      background: #fff;
    }
    .role-compose textarea {
      min-height: 58px;
      max-height: 90px;
      resize: vertical;
      font-size: 12px;
      padding: 6px 8px;
    }
    .role-compose button {
      align-self: end;
      padding: 8px 10px;
      font-size: 12px;
    }
    .ptt-mini {
      align-self: end;
      border: 1px solid var(--border);
      background: #fff;
      color: #454245;
      width: 40px;
      height: 40px;
      min-width: 40px;
      padding: 0;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .ptt-mini:hover {
      background: #f8fafc;
      border-color: #c7d0d9;
    }
    .ptt-mini.listening {
      background: #e01e5a;
      border-color: #e01e5a;
      color: #fff;
      box-shadow: 0 0 0 3px rgba(224, 30, 90, 0.2);
    }
    .mic-icon {
      width: 18px;
      height: 18px;
      display: block;
      fill: currentColor;
    }
    .thread-banner {
      display: none;
      grid-column: 1 / -1;
      border: 1px solid #d4e3f3;
      background: #f4f9ff;
      color: #274766;
      font-size: 12px;
      border-radius: 6px;
      padding: 6px 8px;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .thread-banner.show {
      display: flex;
    }
    .thread-cancel {
      border: none;
      background: transparent;
      color: #274766;
      font-weight: 700;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }
    .typing-indicator {
      grid-column: 1 / -1;
      display: none;
      align-items: center;
      gap: 6px;
      width: fit-content;
      max-width: 100%;
      border: 1px solid #d7dee6;
      border-radius: 999px;
      background: #f8fafc;
      padding: 4px 10px;
      font-size: 11px;
      color: var(--text-secondary);
    }
    .typing-indicator.show {
      display: inline-flex;
    }
    .typing-indicator::before {
      content: "...";
      letter-spacing: 1px;
      color: #8a95a3;
      animation: typingPulse 1s ease-in-out infinite;
    }
    @keyframes typingPulse {
      0%, 100% { opacity: 0.35; }
      50% { opacity: 1; }
    }

    .msg-group {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      padding: 4px 0;
    }

    .msg-group:hover {
      background: #f8f8f8;
      /* Subtle hover effect */
    }
    .eval-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.62);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
      padding: 24px;
    }
    .eval-modal.show {
      display: flex;
    }
    .eval-modal-card {
      width: min(100%, 980px);
      max-height: calc(100dvh - 48px);
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 18px 42px rgba(0, 0, 0, 0.25);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .eval-modal-header {
      padding: 14px 18px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f8fafc;
    }
    .eval-modal-title {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .eval-modal-meta {
      font-size: 12px;
      color: var(--text-secondary);
      margin-left: 12px;
    }
    .eval-modal-body {
      padding: 18px;
      overflow-y: auto;
    }
    .eval-modal-actions {
      border-top: 1px solid var(--border);
      padding: 12px 18px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      background: #fcfcfd;
    }
    .welcome-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 60;
      padding: 24px;
    }
    .welcome-modal.show {
      display: flex;
    }
    .welcome-modal-card {
      width: min(100%, 760px);
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 18px 42px rgba(0, 0, 0, 0.22);
      overflow: hidden;
    }
    .welcome-modal-header {
      padding: 18px 22px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .welcome-modal-title {
      margin: 0;
      font-size: 22px;
      font-weight: 800;
      color: #1f2937;
    }
    .welcome-modal-subtitle {
      margin: 0;
      color: var(--text-secondary);
      font-size: 13px;
    }
    .welcome-modal-body {
      padding: 18px 22px 16px;
      color: #1f2937;
      line-height: 1.55;
      font-size: 14px;
      display: grid;
      gap: 12px;
    }
    .welcome-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .welcome-item {
      border: 1px solid #e4e9ef;
      border-radius: 8px;
      background: #f8fafc;
      padding: 10px 12px;
    }
    .welcome-item strong {
      display: block;
      margin-bottom: 4px;
      color: #111827;
      font-size: 13px;
    }
    .welcome-item span {
      color: #4b5563;
      font-size: 12px;
    }
    .welcome-modal-actions {
      padding: 0 22px 20px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .avatar {
      width: 36px;
      height: 36px;
      border-radius: 4px;
      /* Slack uses rounded squares */
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 14px;
      flex-shrink: 0;
    }

    .msg-content {
      flex: 1;
      min-width: 0;
    }

    .msg-header {
      display: flex;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 4px;
    }

    .msg-sender {
      font-weight: 900;
      color: var(--text-primary);
    }

    .msg-time {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .msg-text {
      font-size: 15px;
      line-height: 1.46668;
      color: var(--text-primary);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .msg-actions {
      margin-top: 6px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--text-secondary);
    }
    .msg-action-btn {
      border: none;
      background: transparent;
      color: var(--accent);
      font-size: 11px;
      padding: 0;
      cursor: pointer;
      font-weight: 600;
    }
    .thread-children {
      margin-top: 8px;
      border-left: 2px solid #d9e5f2;
      padding-left: 10px;
      display: grid;
      gap: 8px;
    }
    .thread-item {
      font-size: 13px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 8px;
    }
    .thread-item-header {
      display: flex;
      gap: 8px;
      align-items: baseline;
      margin-bottom: 4px;
    }
    .thread-item-time {
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* Evaluation Card */
    .eval-card {
      padding: 16px;
      font-size: 14px;
    }

    .eval-score {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 8px;
    }

    .eval-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 16px;
    }

    .eval-item {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid var(--sidebar);
      padding-bottom: 4px;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .multi-chat {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 900px) {
      .wrap {
        grid-template-columns: 1fr;
        height: auto;
        overflow: visible;
      }

      .stack {
        height: auto;
        grid-template-rows: auto;
      }

      .role-feed {
        max-height: 320px;
      }

      .ide-content {
        min-height: 400px;
      }
      .snippet-group textarea.code-editor,
      .snippet-group .CodeMirror {
        min-height: 220px;
        max-height: 44vh;
      }

      .welcome-grid {
        grid-template-columns: 1fr;
      }

      .welcome-modal {
        padding: 14px;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">

    <!-- Sidebar / Control Panel -->
    <aside class="panel control-panel">
      <div class="panel-header">
        <div class="panel-title">DayOne.ai</div>
        <div id="status" class="status" style="font-size:11px;">Ready</div>
      </div>

      <div class="panel-body">
        <div class="timer-display" id="timer">10:00</div>

        <div class="form-group">
          <label>Session Configuration</label>
          <select id="sessionMode">
            <option value="600">Standard Simulation (10m)</option>
            <option value="480">Fallback Recovery (8m)</option>
            <option value="60">Quick Smoke Test (60s)</option>
          </select>
        </div>

        <div class="form-group">
          <label>Candidate Name</label>
          <input id="sessionId" value="" placeholder="John Doe">
        </div>

        <div class="btn-row">
          <button id="stopBtn" class="secondary" style="flex:1">Stop</button>
        </div>

        <hr style="border: 0; border-top: 1px solid var(--border); margin: 20px 0;">

        <div class="form-group snippet-group">
          <label>Code Snippet / Patch</label>
          <textarea id="proposedFix" class="code-editor" placeholder="// Paste your solution here..."></textarea>
          <div class="snippet-capture-inline">
            <div id="recordingIndicator" class="recording-indicator" title="Recording in progress" aria-label="Recording in progress">
              <span class="rec-dot" aria-hidden="true"></span>
              <svg class="rec-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M17 10.5V7a2 2 0 0 0-2-2H5A2 2 0 0 0 3 7v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3.5l4 3v-10l-4 3z"/></svg>
            </div>
          </div>
        </div>

        <div class="btn-row snippet-actions">
          <button id="submitCodeBtn" style="flex:1">Submit Patch</button>
          <button id="loadContextBtn" class="secondary">Reload</button>
        </div>

      </div>
    </aside>

    <!-- Main Content Stack -->
    <div class="stack">

      <!-- Top: Code Context (IDE Style) -->
      <section class="panel ide-panel">
        <div class="ide-tabs">
          <div class="ide-tab active" data-key="payment_service">
            <span>JS</span> payment_service.js
          </div>
          <div class="ide-tab" data-key="retry_policy">
            <span>JS</span> retry_policy.js
          </div>
          <div class="ide-tab" data-key="checkout_controller">
            <span>JS</span> checkout_controller.js
          </div>
          <div class="ide-tab" data-key="production_logs">
            <span>LOG</span> production.log
          </div>
          <div class="ide-tab" data-key="business_ticket">
            <span>TKT</span> JIRA-101
          </div>
        </div>
        <div class="ide-content" id="contextBody">
          <pre><code id="contextText" class="language-javascript">Loading context...</code></pre>
        </div>
      </section>

      <!-- Bottom: Split Chat & Eval -->
      <div class="stack-bottom">

        <!-- Chat Interface -->
        <section class="panel chat-panel">
          <div class="panel-header">
            <div class="panel-title"></div>
            <div class="panel-tools">
            </div>
          </div>
          <div class="multi-chat">
            <section class="role-window" data-role="qa">
              <div class="role-header">
                <span class="role-header-main">QA Engineer</span>
                <div class="role-header-tools">
                  <span id="badgeQa" class="role-badge hidden">0</span>
                  <button type="button" class="secondary role-call-btn coming-soon-btn" title="QA video call is coming soon" aria-label="QA video call is coming soon" disabled>
                    <svg class="call-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M17 10.5V7a2 2 0 0 0-2-2H5A2 2 0 0 0 3 7v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3.5l4 3v-10l-4 3z"/></svg>
                  </button>
                </div>
              </div>
              <div id="feedQa" class="role-feed"></div>
              <div class="role-compose">
                <div id="threadQa" class="thread-banner">
                  <span id="threadQaText"></span>
                  <button type="button" class="thread-cancel" data-role="qa" title="Cancel thread">x</button>
                </div>
                <textarea id="inputQa" placeholder="Message QA..."></textarea>
                <button id="sendQa">Send</button>
                <button id="pttQa" type="button" class="ptt-mini" title="Hold to talk with QA" aria-label="Hold to talk with QA">
                  <svg class="mic-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a1 1 0 1 1 2 0 7 7 0 0 1-6 6.92V21h3a1 1 0 1 1 0 2H8a1 1 0 1 1 0-2h3v-3.08A7 7 0 0 1 5 11a1 1 0 1 1 2 0 5 5 0 1 0 10 0z"/></svg>
                </button>
                <div id="typingQa" class="typing-indicator"></div>
              </div>
            </section>
            <section class="role-window" data-role="tech_lead">
              <div class="role-header">
                <span class="role-header-main">Tech Lead</span>
                <div class="role-header-tools">
                  <span id="badgeTech" class="role-badge hidden">0</span>
                  <button type="button" class="secondary role-call-btn coming-soon-btn" title="Tech Lead video call is coming soon" aria-label="Tech Lead video call is coming soon" disabled>
                    <svg class="call-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M17 10.5V7a2 2 0 0 0-2-2H5A2 2 0 0 0 3 7v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3.5l4 3v-10l-4 3z"/></svg>
                  </button>
                </div>
              </div>
              <div id="feedTech" class="role-feed"></div>
              <div class="role-compose">
                <div id="threadTech" class="thread-banner">
                  <span id="threadTechText"></span>
                  <button type="button" class="thread-cancel" data-role="tech_lead" title="Cancel thread">x</button>
                </div>
                <textarea id="inputTech" placeholder="Message Tech Lead..."></textarea>
                <button id="sendTech">Send</button>
                <button id="pttTech" type="button" class="ptt-mini" title="Hold to talk with Tech Lead" aria-label="Hold to talk with Tech Lead">
                  <svg class="mic-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a1 1 0 1 1 2 0 7 7 0 0 1-6 6.92V21h3a1 1 0 1 1 0 2H8a1 1 0 1 1 0-2h3v-3.08A7 7 0 0 1 5 11a1 1 0 1 1 2 0 5 5 0 1 0 10 0z"/></svg>
                </button>
                <div id="typingTech" class="typing-indicator"></div>
              </div>
            </section>
            <section class="role-window" data-role="ba">
              <div class="role-header">
                <span class="role-header-main">Business Analyst</span>
                <div class="role-header-tools">
                  <span id="badgeBa" class="role-badge hidden">0</span>
                  <button type="button" class="secondary role-call-btn coming-soon-btn" title="BA video call is coming soon" aria-label="BA video call is coming soon" disabled>
                    <svg class="call-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M17 10.5V7a2 2 0 0 0-2-2H5A2 2 0 0 0 3 7v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3.5l4 3v-10l-4 3z"/></svg>
                  </button>
                </div>
              </div>
              <div id="feedBa" class="role-feed"></div>
              <div class="role-compose">
                <div id="threadBa" class="thread-banner">
                  <span id="threadBaText"></span>
                  <button type="button" class="thread-cancel" data-role="ba" title="Cancel thread">x</button>
                </div>
                <textarea id="inputBa" placeholder="Message BA..."></textarea>
                <button id="sendBa">Send</button>
                <button id="pttBa" type="button" class="ptt-mini" title="Hold to talk with BA" aria-label="Hold to talk with BA">
                  <svg class="mic-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a1 1 0 1 1 2 0 7 7 0 0 1-6 6.92V21h3a1 1 0 1 1 0 2H8a1 1 0 1 1 0-2h3v-3.08A7 7 0 0 1 5 11a1 1 0 1 1 2 0 5 5 0 1 0 10 0z"/></svg>
                </button>
                <div id="typingBa" class="typing-indicator"></div>
              </div>
            </section>
          </div>
        </section>
      </div>
    </div>
  </div>

  <div id="evalModal" class="eval-modal" aria-hidden="true">
    <section class="eval-modal-card" role="dialog" aria-modal="true" aria-labelledby="evalModalTitle">
      <div class="eval-modal-header">
        <div>
          <h2 id="evalModalTitle" class="eval-modal-title">Post-session Report</h2>
          <span id="evalModalMeta" class="eval-modal-meta"></span>
        </div>
        <button id="closeEvalModalBtn" class="secondary">Close</button>
      </div>
      <div class="eval-modal-body">
        <div id="evaluation">Waiting for session end...</div>
      </div>
      <div class="eval-modal-actions">
        <button id="closeEvalModalBtnBottom" class="secondary">Back to workspace</button>
      </div>
    </section>
  </div>

  <div id="welcomeModal" class="welcome-modal" aria-hidden="true">
    <section class="welcome-modal-card" role="dialog" aria-modal="true" aria-labelledby="welcomeModalTitle">
      <div class="welcome-modal-header">
        <div>
          <h2 id="welcomeModalTitle" class="welcome-modal-title">Welcome to the DayOne.ai Team Simulation</h2>
          <p class="welcome-modal-subtitle">You are stepping into a realistic day-in-the-life incident workflow with QA, BA, and Tech Lead.</p>
        </div>
        <button id="welcomeCloseBtn" class="secondary" type="button">Close</button>
      </div>
      <div class="welcome-modal-body">
        <div>
          Great to have you here, and welcome to the team. Today you will experience a realistic DayOne.ai workday:
          balancing a live payment incident while handling business delivery pressure in real time.
        </div>
        <div>
          Please use the first <strong>~45 seconds</strong> to quickly review the context tabs before you start working:
        </div>
        <div class="welcome-grid">
          <div class="welcome-item"><strong>`payment_service.js`</strong><span>Main bug surface in payment flow.</span></div>
          <div class="welcome-item"><strong>`retry_policy.js`</strong><span>Retry behavior that can amplify incidents.</span></div>
          <div class="welcome-item"><strong>`checkout_controller.js`</strong><span>Checkout orchestration and integration points.</span></div>
          <div class="welcome-item"><strong>`production.log`</strong><span>Evidence trail and real-time impact hints.</span></div>
          <div class="welcome-item"><strong>`JIRA-101` ticket</strong><span>Business pressure and scope expectations.</span></div>
          <div class="welcome-item"><strong>Chat channels</strong><span>QA, Tech Lead, BA threads for targeted replies.</span></div>
        </div>
        <div>
          Process overview: review context, ask clarifying questions, propose containment/fix direction, then submit your patch and final decision framing.
          Good luck, we are excited to see how you approach this.
        </div>
      </div>
      <div class="welcome-modal-actions">
        <button id="welcomeContinueBtn" class="primary" type="button">Got it, let's begin</button>
      </div>
    </section>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>

  <script>
    const sessionIdEl = document.getElementById("sessionId");
    const proposedFixEl = document.getElementById("proposedFix");
    const statusEl = document.getElementById("status");
    const timerEl = document.getElementById("timer");
    const sessionModeEl = document.getElementById("sessionMode");
    const feedQaEl = document.getElementById("feedQa");
    const feedTechEl = document.getElementById("feedTech");
    const feedBaEl = document.getElementById("feedBa");
    const inputQaEl = document.getElementById("inputQa");
    const inputTechEl = document.getElementById("inputTech");
    const inputBaEl = document.getElementById("inputBa");
    const sendQaEl = document.getElementById("sendQa");
    const sendTechEl = document.getElementById("sendTech");
    const sendBaEl = document.getElementById("sendBa");
    const threadQaEl = document.getElementById("threadQa");
    const threadTechEl = document.getElementById("threadTech");
    const threadBaEl = document.getElementById("threadBa");
    const threadQaTextEl = document.getElementById("threadQaText");
    const threadTechTextEl = document.getElementById("threadTechText");
    const threadBaTextEl = document.getElementById("threadBaText");
    const typingQaEl = document.getElementById("typingQa");
    const typingTechEl = document.getElementById("typingTech");
    const typingBaEl = document.getElementById("typingBa");
    const badgeQaEl = document.getElementById("badgeQa");
    const badgeTechEl = document.getElementById("badgeTech");
    const badgeBaEl = document.getElementById("badgeBa");
    const evalModalEl = document.getElementById("evalModal");
    const evalModalMetaEl = document.getElementById("evalModalMeta");
    const closeEvalModalBtnEl = document.getElementById("closeEvalModalBtn");
    const closeEvalModalBtnBottomEl = document.getElementById("closeEvalModalBtnBottom");
    const welcomeModalEl = document.getElementById("welcomeModal");
    const welcomeCloseBtnEl = document.getElementById("welcomeCloseBtn");
    const welcomeContinueBtnEl = document.getElementById("welcomeContinueBtn");
    const contextTextEl = document.getElementById("contextText");
    const evaluationEl = document.getElementById("evaluation");
    const tabs = Array.from(document.querySelectorAll(".ide-tab"));
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const recordingIndicatorEl = document.getElementById("recordingIndicator");
    const pttQaEl = document.getElementById("pttQa");
    const pttTechEl = document.getElementById("pttTech");
    const pttBaEl = document.getElementById("pttBa");
    const submitCodeBtn = document.getElementById("submitCodeBtn");

    const defaultSessionId = "John Doe";
    sessionIdEl.value = defaultSessionId;
    let contextCache = null;
    let activeContextKey = "payment_service";
    let sessionStarted = false;
    let sessionStartedOnce = false;
    let sessionEndAtMs = null;
    let countdownInterval = null;
    let scheduledTimeouts = [];
    let startInFlight = false;
    let sendInFlight = false;
    let lastMessagesSignature = "";
    const roleKeys = ["qa", "tech_lead", "ba"];
    const roleFeeds = { qa: feedQaEl, tech_lead: feedTechEl, ba: feedBaEl };
    const roleInputs = { qa: inputQaEl, tech_lead: inputTechEl, ba: inputBaEl };
    const roleSendButtons = { qa: sendQaEl, tech_lead: sendTechEl, ba: sendBaEl };
    const roleThreadBanners = { qa: threadQaEl, tech_lead: threadTechEl, ba: threadBaEl };
    const roleThreadTexts = { qa: threadQaTextEl, tech_lead: threadTechTextEl, ba: threadBaTextEl };
    const roleTypingEls = { qa: typingQaEl, tech_lead: typingTechEl, ba: typingBaEl };
    const rolePttButtons = { qa: pttQaEl, tech_lead: pttTechEl, ba: pttBaEl };
    const roleBadges = { qa: badgeQaEl, tech_lead: badgeTechEl, ba: badgeBaEl };
    const roleUnread = { qa: 0, tech_lead: 0, ba: 0 };
    const roleLastCounts = { qa: 0, tech_lead: 0, ba: 0 };
    const roleLastAgentMessageKey = { qa: "", tech_lead: "", ba: "" };
    const roleThreadTarget = { qa: null, tech_lead: null, ba: null };
    const roleTypingTimer = { qa: null, tech_lead: null, ba: null };
    const roleTypingSignalTimer = { qa: null, tech_lead: null, ba: null };
    const roleTypingSignalActive = { qa: false, tech_lead: false, ba: false };
    let lastMessages = [];
    let activeRole = "qa";
    const STT_CONFIDENCE_THRESHOLD = 0.72;
    let sttLowConfidenceCount = 0;
    let micActive = false;
    let sttListening = false;
    let sttTargetRole = "tech_lead";
    let sttBuffer = "";
    let sttConfidence = 1;
    let sttStopRequested = false;
    const SpeechRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition || null;
    const stt = SpeechRecognitionCtor ? new SpeechRecognitionCtor() : null;
    let codeEditor = null;
    let mediaRecorder = null;
    let recordingStream = null;
    let screenCaptureStream = null;
    let webcamCaptureStream = null;
    let recordingCanvas = null;
    let recordingCanvasCtx = null;
    let recordingFrameReq = 0;
    let screenVideoPreview = null;
    let webcamVideoPreview = null;
    let recordingChunks = [];
    let recordingStartedAtMs = 0;
    let recordingTicker = null;
    let recordingStopResolver = null;
    let recordingUploading = false;
    let lastRecordingUrl = "";

    function setStatus(text, isError = false) {
      statusEl.textContent = text;
      statusEl.style.color = isError ? "#b42318" : "#6f655b";
    }

    function formatRecordingTimer(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const mm = String(Math.floor(totalSec / 60)).padStart(2, "0");
      const ss = String(totalSec % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function setRecordingStatus(text, isError = false, isLive = false) {
      if (recordingIndicatorEl) {
        recordingIndicatorEl.classList.toggle("show", !!isLive);
        recordingIndicatorEl.classList.toggle("live", !!isLive && !isError);
        recordingIndicatorEl.title = text || "Interview recording";
        recordingIndicatorEl.setAttribute("aria-label", text || "Interview recording");
      }
      if (isError && text) {
        setStatus(text, true);
      }
    }

    function refreshRecordingButtons() {
      const recordingActive = !!(mediaRecorder && mediaRecorder.state === "recording");
      if (!recordingIndicatorEl) return;
      recordingIndicatorEl.classList.toggle("show", recordingActive);
      recordingIndicatorEl.classList.toggle("live", recordingActive);
    }

    function pickRecordingMimeType() {
      if (!window.MediaRecorder || typeof window.MediaRecorder.isTypeSupported !== "function") {
        return "";
      }
      const candidates = [
        "video/webm;codecs=vp9,opus",
        "video/webm;codecs=vp8,opus",
        "video/webm",
        "video/mp4"
      ];
      for (const candidate of candidates) {
        if (window.MediaRecorder.isTypeSupported(candidate)) {
          return candidate;
        }
      }
      return "";
    }

    function stopStreamTracks(stream) {
      if (!stream) return;
      for (const track of stream.getTracks()) {
        try { track.stop(); } catch { }
      }
    }

    function stopRecordingTracks() {
      if (recordingFrameReq) {
        cancelAnimationFrame(recordingFrameReq);
        recordingFrameReq = 0;
      }
      stopStreamTracks(recordingStream);
      stopStreamTracks(screenCaptureStream);
      stopStreamTracks(webcamCaptureStream);
      recordingStream = null;
      screenCaptureStream = null;
      webcamCaptureStream = null;
      recordingCanvas = null;
      recordingCanvasCtx = null;
      if (screenVideoPreview) {
        try { screenVideoPreview.pause(); } catch { }
        screenVideoPreview.srcObject = null;
      }
      if (webcamVideoPreview) {
        try { webcamVideoPreview.pause(); } catch { }
        webcamVideoPreview.srcObject = null;
      }
      screenVideoPreview = null;
      webcamVideoPreview = null;
    }

    function drawRoundedRectPath(ctx, x, y, w, h, r) {
      const radius = Math.max(0, Math.min(r, Math.floor(Math.min(w, h) / 2)));
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function renderRecordingFrame() {
      if (!recordingCanvasCtx || !recordingCanvas || !screenVideoPreview || !webcamVideoPreview) {
        return;
      }
      const width = recordingCanvas.width;
      const height = recordingCanvas.height;

      recordingCanvasCtx.fillStyle = "#0f172a";
      recordingCanvasCtx.fillRect(0, 0, width, height);
      recordingCanvasCtx.drawImage(screenVideoPreview, 0, 0, width, height);

      const camAspect =
        webcamVideoPreview.videoWidth > 0 && webcamVideoPreview.videoHeight > 0
          ? webcamVideoPreview.videoWidth / webcamVideoPreview.videoHeight
          : 16 / 9;
      const margin = Math.max(14, Math.floor(width * 0.015));
      const camWidth = Math.max(180, Math.floor(width * 0.22));
      const camHeight = Math.max(110, Math.floor(camWidth / camAspect));
      const camX = width - camWidth - margin;
      const camY = height - camHeight - margin;

      recordingCanvasCtx.save();
      drawRoundedRectPath(recordingCanvasCtx, camX, camY, camWidth, camHeight, 14);
      recordingCanvasCtx.fillStyle = "rgba(2, 6, 23, 0.75)";
      recordingCanvasCtx.fill();
      recordingCanvasCtx.clip();
      recordingCanvasCtx.drawImage(webcamVideoPreview, camX + 2, camY + 2, camWidth - 4, camHeight - 4);
      recordingCanvasCtx.restore();

      recordingCanvasCtx.save();
      drawRoundedRectPath(recordingCanvasCtx, camX, camY, camWidth, camHeight, 14);
      recordingCanvasCtx.strokeStyle = "rgba(255,255,255,0.92)";
      recordingCanvasCtx.lineWidth = 2;
      recordingCanvasCtx.stroke();
      recordingCanvasCtx.restore();

      recordingFrameReq = requestAnimationFrame(renderRecordingFrame);
    }

    function waitForVideoReady(videoEl, timeoutMs = 8000) {
      return new Promise((resolve, reject) => {
        let done = false;
        let timeoutId = null;
        const finish = (fn, value) => {
          if (done) return;
          done = true;
          if (timeoutId) clearTimeout(timeoutId);
          videoEl.removeEventListener("loadedmetadata", onLoaded);
          videoEl.removeEventListener("error", onError);
          fn(value);
        };
        const onLoaded = () => finish(resolve);
        const onError = () => finish(reject, new Error("video_stream_unavailable"));
        if (videoEl.readyState >= 1 && videoEl.videoWidth > 0) {
          resolve();
          return;
        }
        videoEl.addEventListener("loadedmetadata", onLoaded, { once: true });
        videoEl.addEventListener("error", onError, { once: true });
        timeoutId = setTimeout(() => {
          finish(reject, new Error("video_stream_timeout"));
        }, timeoutMs);
      });
    }

    async function createCompositeRecordingStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia || !navigator.mediaDevices.getUserMedia) {
        throw new Error("recording_not_supported");
      }

      screenCaptureStream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          frameRate: { ideal: 24, max: 30 },
          cursor: "always"
        },
        audio: false
      });
      webcamCaptureStream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 360 },
          frameRate: { ideal: 24, max: 30 }
        },
        audio: false
      });

      screenVideoPreview = document.createElement("video");
      webcamVideoPreview = document.createElement("video");
      screenVideoPreview.muted = true;
      webcamVideoPreview.muted = true;
      screenVideoPreview.playsInline = true;
      webcamVideoPreview.playsInline = true;
      screenVideoPreview.srcObject = screenCaptureStream;
      webcamVideoPreview.srcObject = webcamCaptureStream;
      await Promise.all([
        screenVideoPreview.play().catch(() => { }),
        webcamVideoPreview.play().catch(() => { })
      ]);
      await Promise.all([
        waitForVideoReady(screenVideoPreview),
        waitForVideoReady(webcamVideoPreview)
      ]);

      const width = Math.max(960, screenVideoPreview.videoWidth || 1280);
      const height = Math.max(540, screenVideoPreview.videoHeight || 720);
      recordingCanvas = document.createElement("canvas");
      recordingCanvas.width = width;
      recordingCanvas.height = height;
      recordingCanvasCtx = recordingCanvas.getContext("2d");
      if (!recordingCanvasCtx) {
        throw new Error("canvas_context_failed");
      }

      renderRecordingFrame();
      recordingStream = recordingCanvas.captureStream(24);

      const onAnyTrackEnded = () => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopScreenRecording(true).catch(() => { });
        }
      };
      const screenTrack = screenCaptureStream.getVideoTracks()[0];
      const webcamTrack = webcamCaptureStream.getVideoTracks()[0];
      if (screenTrack) screenTrack.addEventListener("ended", onAnyTrackEnded, { once: true });
      if (webcamTrack) webcamTrack.addEventListener("ended", onAnyTrackEnded, { once: true });
    }

    async function uploadScreenRecording(blob) {
      const sessionId = sessionIdEl.value.trim();
      if (!sessionId) {
        setRecordingStatus("Missing candidate name / session id for recording upload.", true, false);
        return;
      }
      recordingUploading = true;
      refreshRecordingButtons();
      try {
        const type = String(blob.type || "video/webm");
        const ext = type.includes("mp4") ? "mp4" : type.includes("quicktime") ? "mov" : "webm";
        const fileName = `${sessionId}_${Date.now()}.${ext}`;
        const res = await fetch(`/api/session/recording?session_id=${encodeURIComponent(sessionId)}`, {
          method: "POST",
          headers: {
            "Content-Type": type,
            "X-Filename": fileName
          },
          body: blob
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || "recording_upload_failed");
        lastRecordingUrl = data.recording?.url || "";
        setStatus("Interview recording uploaded.");
      } catch (err) {
        const msg = err?.message || "recording_upload_failed";
        setRecordingStatus(`Recording upload failed: ${msg}`, true, false);
      } finally {
        recordingUploading = false;
        refreshRecordingButtons();
      }
    }

    async function startScreenRecording(silent = false) {
      if (!sessionStarted) {
        setRecordingStatus("Start the simulation before recording.", true, false);
        return false;
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia || !window.MediaRecorder) {
        setRecordingStatus("Interview recording is not supported in this browser.", true, false);
        return false;
      }
      if (mediaRecorder && mediaRecorder.state === "recording") return true;
      try {
        await createCompositeRecordingStream();
        recordingChunks = [];
        const mimeType = pickRecordingMimeType();
        mediaRecorder = mimeType
          ? new MediaRecorder(recordingStream, { mimeType })
          : new MediaRecorder(recordingStream);

        mediaRecorder.ondataavailable = (ev) => {
          if (ev.data && ev.data.size > 0) {
            recordingChunks.push(ev.data);
          }
        };

        mediaRecorder.onerror = () => {
          setRecordingStatus("Recording failed. Please try again.", true, false);
        };

        mediaRecorder.onstop = async () => {
          if (recordingTicker) {
            clearInterval(recordingTicker);
            recordingTicker = null;
          }
          const chunks = recordingChunks.slice();
          recordingChunks = [];
          const mime = String((mediaRecorder && mediaRecorder.mimeType) || "video/webm");
          mediaRecorder = null;
          stopRecordingTracks();
          if (chunks.length) {
            const blob = new Blob(chunks, { type: mime });
            await uploadScreenRecording(blob);
          } else {
            setRecordingStatus("Recording stopped. No media captured.", true, false);
          }
          if (recordingStopResolver) {
            const resolve = recordingStopResolver;
            recordingStopResolver = null;
            resolve();
          }
          refreshRecordingButtons();
        };

        recordingStartedAtMs = Date.now();
        mediaRecorder.start(1000);
        setRecordingStatus("Recording screen and webcam in progress", false, true);
        recordingTicker = setInterval(() => {
          const elapsed = Date.now() - recordingStartedAtMs;
          if (recordingIndicatorEl) {
            recordingIndicatorEl.title = `Recording screen + webcam (${formatRecordingTimer(elapsed)})`;
          }
        }, 1000);
        refreshRecordingButtons();
        if (!silent) {
          setStatus("Interview recording started.");
        }
        return true;
      } catch {
        mediaRecorder = null;
        stopRecordingTracks();
        setRecordingStatus("Recording needs both screen-share and webcam permissions.", true, false);
        refreshRecordingButtons();
        return false;
      }
    }

    async function stopScreenRecording(silent = false) {
      if (!mediaRecorder || mediaRecorder.state !== "recording") return;
      if (recordingTicker) {
        clearInterval(recordingTicker);
        recordingTicker = null;
      }
      const waitForStop = new Promise((resolve) => {
        recordingStopResolver = resolve;
      });
      try {
        mediaRecorder.stop();
      } catch {
        if (recordingStopResolver) {
          const resolve = recordingStopResolver;
          recordingStopResolver = null;
          resolve();
        }
      }
      if (!silent) {
        setStatus("Stopping recording...");
      }
      await waitForStop;
    }

    function initCodeEditor() {
      if (!window.CodeMirror || !proposedFixEl) return;
      codeEditor = window.CodeMirror.fromTextArea(proposedFixEl, {
        mode: "javascript",
        theme: "eclipse",
        lineNumbers: true,
        lineWrapping: true,
        tabSize: 2,
        indentUnit: 2,
        autofocus: false
      });
      codeEditor.setValue(proposedFixEl.value || "");
      codeEditor.on("change", () => {
        proposedFixEl.value = codeEditor.getValue();
      });
    }

    function getProposedCode() {
      if (codeEditor) {
        return codeEditor.getValue();
      }
      return proposedFixEl.value;
    }

    function normalizeRoleKey(role) {
      const raw = String(role || "").toLowerCase();
      return raw === "techlead" ? "tech_lead" : raw;
    }

    async function sendSessionSignal(eventType, data = {}) {
      const sessionId = sessionIdEl.value.trim();
      if (!sessionStarted || !sessionId) return;
      try {
        await fetch("/api/session/event", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            session_id: sessionId,
            event_type: eventType,
            data
          })
        });
      } catch {
        // no-op for signaling failures in MVP
      }
    }

    function setTypingSignal(roleKey, active) {
      const next = !!active;
      if (roleTypingSignalActive[roleKey] === next) return;
      roleTypingSignalActive[roleKey] = next;
      sendSessionSignal("typing_state_changed", { role: roleKey, typing_active: next });
    }

    async function sendAgentNudge(roleKey, text) {
      const sessionId = sessionIdEl.value.trim();
      await fetch("/sim/session/agent-message", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          session_id: sessionId,
          message_id: `msg_stt_nudge_${Date.now()}`,
          agent: normalizeRoleKey(roleKey) || "tech_lead",
          kind: "question",
          text
        })
      });
      setTimeout(() => refreshMessages(true), 250);
    }

    function updatePttVisual() {
      for (const roleKey of roleKeys) {
        const btn = rolePttButtons[roleKey];
        if (!btn) continue;
        const isListeningHere = (sttListening || micActive) && sttTargetRole === roleKey;
        btn.classList.toggle("listening", isListeningHere);
        btn.setAttribute("aria-pressed", isListeningHere ? "true" : "false");
        const baseTitle = `Hold to talk with ${getRoleMeta(roleKey).name}`;
        btn.title = isListeningHere ? `Listening: ${getRoleMeta(roleKey).name}` : baseTitle;
      }
    }

    async function processVoiceTranscript(transcript, confidence, targetRole) {
      const sessionId = sessionIdEl.value.trim();
      if (!sessionId || !transcript.trim()) return;
      const role = normalizeRoleKey(targetRole || sttTargetRole || "tech_lead");
      setRoleTyping(role, `${getRoleMeta(role).name} is typing...`);
      await dispatchCandidateEvent(sessionId, transcript, role, "");
      setTimeout(() => refreshMessages(true), 250);

      if (confidence < STT_CONFIDENCE_THRESHOLD) {
        sttLowConfidenceCount += 1;
        if (sttLowConfidenceCount >= 2) {
          await sendAgentNudge(
            role,
            "I still could not catch that clearly. Please type a short response."
          );
          setRoleTyping(role, `Low confidence ${confidence.toFixed(2)}. Asked to type.`);
        } else {
          await sendAgentNudge(
            role,
            "I did not catch that clearly. Could you repeat briefly?"
          );
          setRoleTyping(role, `Low confidence ${confidence.toFixed(2)}. Asked for repeat.`);
        }
      } else {
        sttLowConfidenceCount = 0;
        setRoleTyping(role, `Voice sent (${confidence.toFixed(2)}).`);
      }
    }

    function setupSpeechRecognition() {
      if (!stt) {
        for (const roleKey of roleKeys) {
          rolePttButtons[roleKey].disabled = true;
          setRoleTyping(roleKey, "Speech recognition not supported.");
        }
        return;
      }

      stt.lang = "en-US";
      stt.continuous = true;
      stt.interimResults = true;

      stt.onstart = () => {
        sttListening = true;
        sttBuffer = "";
        sttConfidence = 1;
        updatePttVisual();
        setRoleTyping(sttTargetRole, `Listening to ${getRoleMeta(sttTargetRole).name}...`);
      };

      stt.onresult = (event) => {
        let finalText = "";
        let finalConfidence = sttConfidence;
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          if (!res || !res[0]) continue;
          if (res.isFinal) {
            finalText += `${res[0].transcript || ""} `;
            if (typeof res[0].confidence === "number" && res[0].confidence > 0) {
              finalConfidence = Math.min(finalConfidence, res[0].confidence);
            }
          }
        }
        if (finalText.trim()) {
          sttBuffer += `${finalText.trim()} `;
          sttConfidence = finalConfidence;
        }
      };

      stt.onerror = (event) => {
        sttListening = false;
        micActive = false;
        updatePttVisual();
        const message = event?.error || "stt_error";
        setRoleTyping(sttTargetRole, `Voice error: ${message}`);
      };

      stt.onend = async () => {
        sttListening = false;
        updatePttVisual();
        await sendSessionSignal("speech_end", {});
        try {
          if (sttBuffer.trim()) {
            await processVoiceTranscript(sttBuffer.trim(), sttConfidence, sttTargetRole);
          } else if (sttStopRequested) {
            setRoleTyping(sttTargetRole, "No speech captured. Hold and try again.");
          }
        } catch (err) {
          const msg = err?.message || "voice_dispatch_failed";
          setRoleTyping(sttTargetRole, `Voice send failed: ${msg}`);
        }
        sttStopRequested = false;
        micActive = false;
        updatePttVisual();
      };
    }

    async function startVoiceCapture(roleKey) {
      if (!sessionStarted) {
        setRoleTyping(roleKey, "Start session before using voice.");
        return;
      }
      if (!stt || sttListening || micActive) return;
      sttTargetRole = normalizeRoleKey(roleKey || sttTargetRole);
      micActive = true;
      sttStopRequested = false;
      updatePttVisual();
      await sendSessionSignal("mic_state_changed", { mic_active: true });
      try {
        stt.start();
      } catch {
        micActive = false;
        updatePttVisual();
      }
    }

    async function stopVoiceCapture() {
      if (!stt || !micActive) return;
      sttStopRequested = true;
      await sendSessionSignal("mic_state_changed", { mic_active: false });
      try {
        stt.stop();
      } catch {
        micActive = false;
        updatePttVisual();
      }
    }

    function formatTimestamp(isoStr) {
      if (!isoStr) return "";
      const date = new Date(isoStr);
      if (isNaN(date.getTime())) return isoStr;

      // Intelligent timestamp: "Today at 10:42 AM"
      const now = new Date();
      const isToday = date.getDate() === now.getDate() &&
        date.getMonth() === now.getMonth() &&
        date.getFullYear() === now.getFullYear();

      const timeStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      return isToday ? `Today at ${timeStr}` : `${date.toLocaleDateString()} ${timeStr}`;
    }

    function getRoleMeta(roleRaw) {
      const role = (roleRaw || "system").toLowerCase().replace(" ", "_");
      switch (role) {
        case "qa": return { name: "QA Engineer", color: "var(--role-qa)", initials: "QA" };
        case "ba": return { name: "Business Analyst", color: "var(--role-ba)", initials: "BA" };
        case "tech_lead": return { name: "Tech Lead", color: "var(--role-tech-lead)", initials: "TL" };
        case "candidate": return { name: "Candidate (You)", color: "var(--role-candidate)", initials: "Me" };
        default: return { name: "System", color: "var(--role-system)", initials: "SYS" };
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function isNearBottom(el) {
      return el.scrollHeight - (el.scrollTop + el.clientHeight) < 56;
    }

    function messageKey(message) {
      const p = message?.payload || {};
      return String(
        p.message_id ||
        `${p.agent || "system"}:${message?.received_at || ""}:${p.text || ""}`
      );
    }

    function setRoleTyping(roleKey, text) {
      const el = roleTypingEls[roleKey];
      if (!el) return;
      el.textContent = text || "";
      el.classList.toggle("show", !!text);
    }

    function pulseRoleTyping(roleKey, text, holdMs = 1800) {
      clearTimeout(roleTypingTimer[roleKey]);
      setRoleTyping(roleKey, text);
      roleTypingTimer[roleKey] = setTimeout(() => {
        setRoleTyping(roleKey, "");
      }, holdMs);
    }

    function setThreadTarget(roleKey, target) {
      roleThreadTarget[roleKey] = target;
      const banner = roleThreadBanners[roleKey];
      const text = roleThreadTexts[roleKey];
      if (!target) {
        banner.classList.remove("show");
        text.textContent = "";
        return;
      }
      banner.classList.add("show");
      text.textContent = `Replying in thread: ${target.preview}`;
    }

    function clearThreadTarget(roleKey) {
      setThreadTarget(roleKey, null);
    }

    function roleScopedMessages(allItems, roleKey) {
      return allItems.filter((m) => {
        const p = m?.payload || {};
        const agent = String(p.agent || "system");
        const addressedRaw = String(
          p?.meta?.addressed_to || p?.addressed_to || ""
        ).toLowerCase();
        const addressed =
          addressedRaw === "techlead" ? "tech_lead" : addressedRaw;
        const candidateInRole =
          agent === "candidate" && addressed && addressed === roleKey;
        const inRole = agent === roleKey || candidateInRole || agent === "system";
        if (!inRole) return false;
        return true;
      });
    }

    function renderThreadItem(message) {
      const p = message.payload || {};
      const at = message.received_at ? formatTimestamp(message.received_at) : "";
      const meta = getRoleMeta(p.agent || "system");
      const text = p.text || "";
      return `
        <div class="thread-item">
          <div class="thread-item-header">
            <strong>${escapeHtml(meta.name)}</strong>
            <span class="thread-item-time">${escapeHtml(at)}</span>
          </div>
          <div>${escapeHtml(text)}</div>
        </div>
      `;
    }

    function renderFeed(roleKey, allItems) {
      const feed = roleFeeds[roleKey];
      const prevScrollTop = feed.scrollTop;
      const prevScrollHeight = feed.scrollHeight;
      const wasNearBottom = isNearBottom(feed);
      const prevDistanceFromBottom = prevScrollHeight - prevScrollTop;
      const items = roleScopedMessages(allItems, roleKey);

      feed.innerHTML = "";
      if (!sessionStartedOnce) {
        feed.innerHTML = `
          <div class="msg-group">
            <div class="avatar" style="background: var(--role-system)">SYS</div>
            <div class="msg-content">
              <div class="msg-header"><span class="msg-sender">System</span></div>
              <div class="msg-text">Start session to open this channel.</div>
            </div>
          </div>`;
        roleLastCounts[roleKey] = 1;
        roleUnread[roleKey] = 0;
        return;
      }

      if (!items.length) {
        feed.innerHTML = `
          <div class="msg-group">
            <div class="avatar" style="background: var(--role-system)">SYS</div>
            <div class="msg-content">
              <div class="msg-header"><span class="msg-sender">System</span></div>
              <div class="msg-text">No conversation in this channel yet.</div>
            </div>
          </div>`;
        roleLastCounts[roleKey] = 0;
        roleUnread[roleKey] = 0;
        return;
      }

      const itemByKey = new Map();
      for (const m of items) {
        itemByKey.set(messageKey(m), m);
      }
      const threadChildren = new Map();
      const rootItems = [];
      for (const m of items) {
        const p = m.payload || {};
        const rootId = String(p.thread_root || "");
        if (rootId && itemByKey.has(rootId)) {
          if (!threadChildren.has(rootId)) {
            threadChildren.set(rootId, []);
          }
          threadChildren.get(rootId).push(m);
          continue;
        }
        rootItems.push(m);
      }

      for (const m of rootItems) {
        const p = m.payload || {};
        const role = p.agent || "system";
        const text = p.text || JSON.stringify(p);
        const at = m.received_at ? formatTimestamp(m.received_at) : "";
        const meta = getRoleMeta(role);
        const rootId = messageKey(m);
        const replies = threadChildren.get(rootId) || [];
        const preview = text.length > 80 ? `${text.slice(0, 80)}...` : text;

        const el = document.createElement("div");
        el.className = "msg-group";
        el.innerHTML = `
          <div class="avatar" style="background: ${meta.color}">${meta.initials}</div>
          <div class="msg-content">
            <div class="msg-header">
              <span class="msg-sender">${escapeHtml(meta.name)}</span>
              <span class="msg-time">${escapeHtml(at)}</span>
            </div>
            <div class="msg-text">${escapeHtml(text)}</div>
            <div class="msg-actions">
              <button type="button" class="msg-action-btn thread-reply-btn" data-role="${roleKey}" data-root-id="${escapeHtml(rootId)}" data-preview="${escapeHtml(preview)}">Reply in thread</button>
              ${replies.length ? `<span>${replies.length} repl${replies.length > 1 ? "ies" : "y"}</span>` : ""}
            </div>
            ${replies.length ? `<div class="thread-children">${replies.map(renderThreadItem).join("")}</div>` : ""}
          </div>
        `;
        feed.appendChild(el);
      }

      const newCount = rootItems.length;
      const delta = Math.max(0, newCount - roleLastCounts[roleKey]);
      roleLastCounts[roleKey] = newCount;
      if (delta > 0 && activeRole !== roleKey && !wasNearBottom) {
        roleUnread[roleKey] += delta;
      }
      if (activeRole === roleKey || wasNearBottom) {
        roleUnread[roleKey] = 0;
      }

      if (wasNearBottom) {
        feed.scrollTop = feed.scrollHeight;
      } else {
        feed.scrollTop = Math.max(0, feed.scrollHeight - prevDistanceFromBottom);
      }
    }

    function renderUnreadBadges() {
      for (const roleKey of roleKeys) {
        const badge = roleBadges[roleKey];
        const unread = roleUnread[roleKey];
        badge.textContent = String(unread);
        badge.classList.toggle("hidden", unread <= 0);
      }
    }

    function renderRoleWindows(allItems) {
      for (const roleKey of roleKeys) {
        renderFeed(roleKey, allItems);
      }
      renderUnreadBadges();
    }

    function renderContext() {
      if (!contextCache) {
        contextTextEl.textContent = "// Context unavailable.";
        return;
      }
      let content = "";
      let lang = "javascript"; // default

      if (activeContextKey === "production_logs") {
        content = contextCache[activeContextKey] || "";
        lang = "log";
      } else if (activeContextKey === "business_ticket") {
        content = contextCache[activeContextKey] || "";
        lang = "markdown";
      } else {
        const files = contextCache.code_files || {};
        content = files[activeContextKey] || "";
      }

      // Update DOM
      contextTextEl.className = `language-${lang}`;
      contextTextEl.textContent = content;

      // Trigger Prism
      if (window.Prism) {
        Prism.highlightElement(contextTextEl);
      }

      for (const tab of tabs) {
        tab.classList.toggle("active", tab.dataset.key === activeContextKey);
      }
    }

    function renderEvaluation(report) {
      if (!report) {
        evaluationEl.innerHTML = `<span style='color:var(--text-muted)'>Waiting for evaluation...</span>`;
        return;
      }
      const r = report.rubric || {};
      const recording = report.recording || null;
      const av = report.voice_video_analysis || null;
      const formatCriteriaLabel = (key) => String(key || "")
        .split("_")
        .filter(Boolean)
        .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
        .join(" ");
      const renderCriteriaRows = (criteriaObj) => {
        const entries = Object.entries(criteriaObj || {});
        if (!entries.length) {
          return `<div style="font-size:12px; color:var(--text-muted);">No criteria available in this placeholder.</div>`;
        }
        return entries
          .map(([key, value]) => {
            const n = Number(value);
            const display = Number.isFinite(n) ? `${Math.round(n)}/100` : "-";
            return `<div class="eval-item"><span>${escapeHtml(formatCriteriaLabel(key))}</span> <strong>${escapeHtml(display)}</strong></div>`;
          })
          .join("");
      };
      const avBlock = av
        ? `<div style="margin-top:12px; padding:10px; border:1px solid #f1d9a8; background:#fff8e8; border-radius:8px;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;">
              <div style="font-size:13px; font-weight:700; color:#7a4f01;">Voice & Video Analysis</div>
              <span style="font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #e9c77a; background:#fff3cf; color:#7a4f01;">MVP Placeholder</span>
            </div>
            <div style="font-size:11px; margin-top:6px; color:#8a6d1d;">
              Simulated metrics only. This is not real voice/video analysis.
            </div>
            <div style="font-size:12px; margin-top:8px; color:#5f4a1f;">
              <strong>Voice summary:</strong> ${escapeHtml(av?.voice?.summary || "-")}
            </div>
            <div class="eval-grid" style="margin-top:8px;">
              ${renderCriteriaRows(av?.voice?.criteria)}
            </div>
            <div style="font-size:12px; margin-top:10px; color:#5f4a1f;">
              <strong>Video summary:</strong> ${escapeHtml(av?.video?.summary || "-")}
            </div>
            <div class="eval-grid" style="margin-top:8px;">
              ${renderCriteriaRows(av?.video?.criteria)}
            </div>
            <div style="font-size:11px; margin-top:8px; color:#8a6d1d;">
              ${escapeHtml(av?.disclaimer || "DayOne.ai MVP note: this section is placeholder and still in development.")}
            </div>
          </div>`
        : "";
      evaluationEl.innerHTML = `
        <div class="eval-score">Score: ${report.total_score} <span style="font-size:14px; color:var(--text-muted)">/ ${report.max_score}</span></div>
        <div style="font-weight:600; margin-bottom:8px;">${report.recommendation}</div>
        <div style="font-size:13px; line-height:1.5; color:var(--text-secondary)">${escapeHtml(report.summary || "")}</div>
        ${avBlock}
        ${recording
          ? `<div style="margin-top:10px; font-size:13px;">
              <strong>Interview Recording (Screen + Webcam):</strong>
              <a href="${escapeHtml(recording.url || "#")}" target="_blank" rel="noopener">Open ${escapeHtml(recording.file_name || "recording")}</a>
            </div>`
          : `<div style="margin-top:10px; font-size:12px; color:var(--text-muted);">Interview Recording: not attached</div>`
        }
        
        <div class="eval-grid">
          <div class="eval-item"><span>Prioritization</span> <strong>${r.prioritization_under_pressure ?? "-"}/5</strong></div>
          <div class="eval-item"><span>Technical Correctness</span> <strong>${r.technical_correctness ?? "-"}/5</strong></div>
          <div class="eval-item"><span>Risk Awareness</span> <strong>${r.production_risk_awareness ?? "-"}/5</strong></div>
          <div class="eval-item"><span>Communication</span> <strong>${r.communication_clarity ?? "-"}/5</strong></div>
        </div>
      `;
    }

    function openEvaluationModal() {
      evalModalEl.classList.add("show");
      evalModalEl.setAttribute("aria-hidden", "false");
    }

    function closeEvaluationModal() {
      evalModalEl.classList.remove("show");
      evalModalEl.setAttribute("aria-hidden", "true");
    }

    function openWelcomeModal() {
      welcomeModalEl.classList.add("show");
      welcomeModalEl.setAttribute("aria-hidden", "false");
    }

    function closeWelcomeModal() {
      welcomeModalEl.classList.remove("show");
      welcomeModalEl.setAttribute("aria-hidden", "true");
    }

    async function refreshMessages(force = false) {
      if (!sessionStartedOnce) {
        lastMessages = [];
        renderRoleWindows([]);
        return;
      }
      const sessionId = sessionIdEl.value.trim();
      const res = await fetch(`/sim/session/messages?session_id=${encodeURIComponent(sessionId)}`);
      const data = await res.json();
      const items = data.messages || [];
      const latest = items.length ? items[items.length - 1] : null;
      const signature = `${sessionId}:${items.length}:${latest?.payload?.message_id || ""}:${latest?.received_at || ""}`;
      if (signature === lastMessagesSignature) {
        return;
      }
      lastMessagesSignature = signature;
      lastMessages = items;
      renderRoleWindows(items);
      for (const roleKey of roleKeys) {
        let latestRoleMessageKey = "";
        for (let i = items.length - 1; i >= 0; i -= 1) {
          if (String(items[i]?.payload?.agent || "") === roleKey) {
            latestRoleMessageKey = messageKey(items[i]);
            break;
          }
        }
        if (!latestRoleMessageKey) {
          roleLastAgentMessageKey[roleKey] = "";
          continue;
        }
        if (roleLastAgentMessageKey[roleKey] !== latestRoleMessageKey) {
          roleLastAgentMessageKey[roleKey] = latestRoleMessageKey;
          setRoleTyping(roleKey, "");
        }
      }
    }

    async function loadContext() {
      const res = await fetch("/api/context");
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "context_failed");
      contextCache = data.context || {};
      renderContext();
    }

    async function startSession() {
      if (startInFlight) return;
      startInFlight = true;
      const sessionId = sessionIdEl.value.trim();
      const durationSec = Number(sessionModeEl.value || 600);
      try {
        if (startBtn) {
          startBtn.disabled = true;
        }
        clearTimeline();
        lastRecordingUrl = "";
        setRecordingStatus("Recording is off.", false, false);
        refreshRecordingButtons();
        for (const roleKey of roleKeys) {
          roleLastAgentMessageKey[roleKey] = "";
          setRoleTyping(roleKey, "");
        }
        await fetch(`/sim/session/messages?session_id=${encodeURIComponent(sessionId)}`, { method: "DELETE" });
        const res = await fetch("/api/session/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, duration_sec: durationSec })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || "start_failed");
        sessionEndAtMs = data.end_at_ms;
        sessionStarted = true;
        sessionStartedOnce = true;
        lockInputs(false);
        resetTimeline(durationSec);
        startCountdown();
        renderEvaluation(null);
        evalModalMetaEl.textContent = "";
        closeEvaluationModal();
        await refreshMessages(true);
        setStatus("Session started: " + sessionId);
        const recordingStarted = await startScreenRecording(true);
        if (!recordingStarted) {
          setStatus("Session started, but recording did not start. Allow screen + webcam permissions and restart.", true);
        }
        refreshRecordingButtons();
      } finally {
        startInFlight = false;
        if (startBtn) {
          startBtn.disabled = sessionStarted;
        }
      }
    }

    async function dispatchCandidateEvent(sessionId, text, addressedTo, threadRoot = "") {
      const res = await fetch("/api/session/event", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          session_id: sessionId,
          event_type: "candidate_message",
          text,
          addressed_to: addressedTo,
          thread_root: threadRoot || ""
        })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "event_failed");
      return data;
    }

    async function sendRoleEvent(roleKey) {
      if (sendInFlight) return;
      const sessionId = sessionIdEl.value.trim();
      const input = roleInputs[roleKey];
      const text = String(input.value || "").trim();
      if (!text) return;
      sendInFlight = true;
      let sentOk = false;
      try {
        roleSendButtons[roleKey].disabled = true;
        const threadRoot = roleThreadTarget[roleKey]?.rootId || "";
        clearTimeout(roleTypingTimer[roleKey]);
        setRoleTyping(roleKey, `${getRoleMeta(roleKey).name} is typing...`);
        await dispatchCandidateEvent(sessionId, text, roleKey, threadRoot);
        sentOk = true;
        input.value = "";
        clearTimeout(roleTypingSignalTimer[roleKey]);
        setTypingSignal(roleKey, false);
        clearThreadTarget(roleKey);
        setStatus(`Sent to ${roleKey}.`);
        setTimeout(() => refreshMessages(true), 250);
      } finally {
        if (!sentOk) {
          setRoleTyping(roleKey, "");
        }
        setTimeout(() => {
          sendInFlight = false;
          for (const k of roleKeys) {
            roleSendButtons[k].disabled = !sessionStarted;
          }
        }, 900);
      }
    }

    async function stopSession() {
      const sessionId = sessionIdEl.value.trim();
      if (mediaRecorder && mediaRecorder.state === "recording") {
        await stopScreenRecording(true);
      }
      const res = await fetch("/api/session/stop", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ session_id: sessionId })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "stop_failed");
      lockInputs(true);
      clearTimeline();
      timerEl.textContent = "00:00";
      sessionStarted = false;
      renderEvaluation(data.evaluation || null);
      evalModalMetaEl.textContent = `Session: ${sessionId}`;
      openEvaluationModal();
      setStatus("Session stopped.");
      sessionStartedOnce = true;
      await refreshMessages(true);
      refreshRecordingButtons();
    }

    async function evaluateSession() {
      const sessionId = sessionIdEl.value.trim();
      const res = await fetch("/api/session/evaluate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ session_id: sessionId })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "evaluate_failed");
      renderEvaluation(data.evaluation || null);
      evalModalMetaEl.textContent = `Session: ${sessionId}`;
      openEvaluationModal();
    }

    async function submitCode() {
      const sessionId = sessionIdEl.value.trim();
      const code = getProposedCode();
      const res = await fetch("/api/session/code", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ session_id: sessionId, code })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "submit_code_failed");
      setStatus("Code submitted.");
      await refreshMessages(true);
    }

    function lockInputs(isLocked) {
      proposedFixEl.disabled = isLocked;
      if (codeEditor) {
        codeEditor.setOption("readOnly", isLocked ? "nocursor" : false);
      }
      submitCodeBtn.disabled = isLocked;
      stopBtn.disabled = isLocked;
      if (startBtn) {
        startBtn.disabled = !isLocked;
      }
      for (const roleKey of roleKeys) {
        roleInputs[roleKey].disabled = isLocked;
        roleSendButtons[roleKey].disabled = isLocked;
        rolePttButtons[roleKey].disabled = isLocked || !stt;
        if (isLocked) {
          setRoleTyping(roleKey, "");
        }
      }
      refreshRecordingButtons();
    }

    function clearTimeline() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
      for (const t of scheduledTimeouts) {
        clearTimeout(t);
      }
      scheduledTimeouts = [];
    }

    function resetTimeline(durationSec = 600) {
      clearTimeline();
      timerEl.textContent = formatTimer(durationSec * 1000);
    }

    function formatTimer(msLeft) {
      const totalSec = Math.max(0, Math.floor(msLeft / 1000));
      const mm = String(Math.floor(totalSec / 60)).padStart(2, "0");
      const ss = String(totalSec % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function startCountdown() {
      if (!sessionEndAtMs) return;
      timerEl.textContent = formatTimer(sessionEndAtMs - Date.now());
      countdownInterval = setInterval(async () => {
        const left = sessionEndAtMs - Date.now();
        timerEl.textContent = formatTimer(left);
        if (left <= 0) {
          clearTimeline();
          try {
            await stopSession();
            await evaluateSession();
          } catch (e) {
            setStatus(e.message, true);
          }
        }
      }, 1000);
    }

    if (startBtn) {
      startBtn.addEventListener("click", async () => {
        try { await startSession(); } catch (e) { setStatus(e.message, true); }
      });
    }
    document.getElementById("stopBtn").addEventListener("click", async () => {
      try { await stopSession(); } catch (e) { setStatus(e.message, true); }
    });
    document.getElementById("submitCodeBtn").addEventListener("click", async () => {
      try { await submitCode(); } catch (e) { setStatus(e.message, true); }
    });
    document.getElementById("loadContextBtn").addEventListener("click", async () => {
      try { await loadContext(); setStatus("Context reloaded."); } catch (e) { setStatus(e.message, true); }
    });
    for (const roleKey of roleKeys) {
      const pttBtn = rolePttButtons[roleKey];
      pttBtn.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        startVoiceCapture(roleKey).catch(() => { });
      });
      pttBtn.addEventListener("pointerup", (ev) => {
        ev.preventDefault();
        stopVoiceCapture().catch(() => { });
      });
      pttBtn.addEventListener("pointerleave", () => {
        stopVoiceCapture().catch(() => { });
      });
      pttBtn.addEventListener("pointercancel", () => {
        stopVoiceCapture().catch(() => { });
      });
      pttBtn.addEventListener("contextmenu", (ev) => ev.preventDefault());
    }
    closeEvalModalBtnEl.addEventListener("click", closeEvaluationModal);
    closeEvalModalBtnBottomEl.addEventListener("click", closeEvaluationModal);
    evalModalEl.addEventListener("click", (ev) => {
      if (ev.target === evalModalEl) {
        closeEvaluationModal();
      }
    });
    welcomeCloseBtnEl.addEventListener("click", closeWelcomeModal);
    welcomeContinueBtnEl.addEventListener("click", async () => {
      closeWelcomeModal();
      try {
        await startSession();
      } catch (e) {
        setStatus(e.message, true);
      }
    });
    welcomeModalEl.addEventListener("click", (ev) => {
      if (ev.target === welcomeModalEl) {
        closeWelcomeModal();
      }
    });
    document.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape" && welcomeModalEl.classList.contains("show")) {
        closeWelcomeModal();
        return;
      }
      if (ev.key === "Escape" && evalModalEl.classList.contains("show")) {
        closeEvaluationModal();
      }
    });
    sessionModeEl.addEventListener("change", () => {
      if (!sessionStarted) {
        resetTimeline(Number(sessionModeEl.value || 600));
      }
    });

    tabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        activeContextKey = tab.dataset.key;
        renderContext();
      });
    });

    for (const roleKey of roleKeys) {
      const feed = roleFeeds[roleKey];
      const sendBtnEl = roleSendButtons[roleKey];
      const inputEl = roleInputs[roleKey];
      feed.addEventListener("pointerenter", () => {
        activeRole = roleKey;
        roleUnread[roleKey] = 0;
        renderUnreadBadges();
      });
      feed.addEventListener("focusin", () => {
        activeRole = roleKey;
        roleUnread[roleKey] = 0;
        renderUnreadBadges();
      });
      feed.addEventListener("click", (ev) => {
        const target = ev.target;
        if (!(target instanceof Element)) return;
        if (!target.classList.contains("thread-reply-btn")) return;
        const rootId = target.getAttribute("data-root-id") || "";
        const preview = target.getAttribute("data-preview") || "";
        setThreadTarget(roleKey, { rootId, preview });
        roleInputs[roleKey].focus();
      });
      sendBtnEl.addEventListener("click", async () => {
        try { await sendRoleEvent(roleKey); } catch (e) { setStatus(e.message, true); }
      });
      inputEl.addEventListener("keydown", async (ev) => {
        if (ev.key === "Enter" && (ev.ctrlKey || ev.metaKey)) {
          ev.preventDefault();
          try { await sendRoleEvent(roleKey); } catch (e) { setStatus(e.message, true); }
        }
      });
      inputEl.addEventListener("input", () => {
        if (!inputEl.value.trim()) {
          setRoleTyping(roleKey, "");
          clearTimeout(roleTypingSignalTimer[roleKey]);
          setTypingSignal(roleKey, false);
          return;
        }
        setRoleTyping(roleKey, "You are typing...");
        clearTimeout(roleTypingTimer[roleKey]);
        roleTypingTimer[roleKey] = setTimeout(() => {
          setRoleTyping(roleKey, "");
        }, 1200);
        setTypingSignal(roleKey, true);
        clearTimeout(roleTypingSignalTimer[roleKey]);
        roleTypingSignalTimer[roleKey] = setTimeout(() => {
          setTypingSignal(roleKey, false);
        }, 3200);
      });
    }
    document.querySelectorAll(".thread-cancel").forEach((btn) => {
      btn.addEventListener("click", () => {
        const role = btn.getAttribute("data-role");
        if (!role || !roleThreadTarget[role]) return;
        clearThreadTarget(role);
      });
    });
    Promise.all([refreshMessages(), loadContext()])
      .catch((e) => setStatus(e.message, true));
    setupSpeechRecognition();
    initCodeEditor();
    lockInputs(true);
    setRecordingStatus("Recording is off.", false, false);
    refreshRecordingButtons();
    resetTimeline(Number(sessionModeEl.value || 600));
    setTimeout(openWelcomeModal, 200);
    setInterval(() => refreshMessages().catch(() => { }), 2000);
    window.addEventListener("beforeunload", () => {
      stopRecordingTracks();
    });
  </script>
</body>

</html>
